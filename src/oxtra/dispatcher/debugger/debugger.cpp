#include "debugger.h"
#include <spdlog/spdlog.h>
#include <sstream>
#include <string>
#include <iostream>

#include "oxtra/dispatcher/dispatcher.h"


//TODO: add riscv-step argument

//TODO: add argument: asm blocks 2

//TODO: add argument read/rd (with warning for no security against segfaults [add state to DebugState])

//TODO: bp eof & bp sof

//TODO bp eof index & bp sof index

//TODO: update print-asm to print the index of the bp it is part of

//TODO: add ability to print asm of any block / print riscv of any instruction

debugger::DebuggerBatch::DebuggerBatch() {
	_adding_jump = false;
}

size_t debugger::DebuggerBatch::add(utils::riscv_instruction_t inst) {
	// add the jump to the debug-procedure (_adding_jump is needed, as jump_debugger_riscv will call add() internally)
	// ignore the first instruction, as the first instruction is generated by the debugger (x86-jump)
	// ignore the second instruction, as there is no reason for an x86-bp followed by a riscv-bp
	if (Debugger::step_riscv() && !_adding_jump && count > 1) {
		_adding_jump = true;
		codegen::jump_table::jump_debugger_riscv(*this);
		_adding_jump = false;
	}
	riscv[count] = inst;
	return count++;
}

void debugger::DebuggerBatch::print() const {
	if (Debugger::step_riscv()) {
		for (size_t i = 1; i < count; i += 2)
			spdlog::trace("    [{:02}] = {}", i / 2, decoding::parse_riscv(riscv[i]));
	} else {
		for (size_t i = 1; i < count; i++)
			spdlog::trace("    [{:02}] = {}", i - 1, decoding::parse_riscv(riscv[i]));
	}
}

debugger::Debugger* debugger::Debugger::active_debugger = nullptr;

debugger::Debugger::Debugger(const elf::Elf& elf, bool riscv_enabled, uintptr_t stack_low, uintptr_t stack_size) : _elf{elf} {
	// initialize the attributes
	_halt = true;
	_bp_count = 0;
	_state = DebugState::none;
	_run_break = 0;
	_current = nullptr;
	_current_index = 1;
	_inst_limit = 12;
	_stack_limit = 12;
	_step_riscv = false;
	_riscv_enabled = riscv_enabled;
	_stack_low = stack_low;
	_stack_high = stack_low + stack_size;

	// mark this as the active debugger
	active_debugger = this;
}

debugger::Debugger::~Debugger() {
	// reset the active debugger
	if (active_debugger == this)
		active_debugger = nullptr;
}

bool debugger::Debugger::step_riscv() {
	// check if a debugger exists
	if (!active_debugger)
		return false;

	return active_debugger->_riscv_enabled;
}

void debugger::Debugger::begin_block(codegen::CodeBatch& batch) {
	unused_parameter(batch);
}

void debugger::Debugger::insert(codegen::CodeBatch& batch, codegen::Instruction* inst) {
	unused_parameter(inst);

	// check if a debugger exists
	if (!active_debugger)
		return;

	// add the instruction to jump to the debugger
	codegen::jump_table::jump_debugger(batch);
}

void debugger::Debugger::end_block(codegen::CodeBatch& batch, codegen::codestore::BlockEntry* block) {
	unused_parameter(batch);

	// check if a debugger exists
	if (!active_debugger)
		return;

	// compute the end of the riscv-instructions
	utils::host_addr_t riscv_end = block->riscv_start;
	for (size_t i = 0; i < block->instruction_count; i++)
		riscv_end += block->offsets[i].riscv;

	// insert the block into the sorted list
	size_t insert_index = active_debugger->_blocks.size() + 1;
	for (size_t i = 0; i < active_debugger->_blocks.size(); i++) {
		if (active_debugger->_blocks[i].entry->x86_start > block->x86_start) {
			active_debugger->_blocks.emplace(active_debugger->_blocks.begin() + i, block, riscv_end);
			insert_index = i;
			break;
		}
	}
	if (insert_index > active_debugger->_blocks.size())
		active_debugger->_blocks.emplace_back(block, riscv_end);
	else if (insert_index >= active_debugger->_current_index)
		active_debugger->_current_index++;

	// update the current block
	if (active_debugger->_current_index != active_debugger->_blocks.size())
		active_debugger->_current = &active_debugger->_blocks[active_debugger->_current_index];
	else
		active_debugger->_current_index = active_debugger->_blocks.size() + 1;

	// update the break-points
	active_debugger->update_break_points(active_debugger->_blocks[insert_index]);
}

void debugger::Debugger::entry(dispatcher::ExecutionContext* context, uintptr_t break_point) {
	// check if the debugger should be entered
	utils::guest_addr_t address = enter_break(break_point, context->guest.ra);
	if (address == 0)
		return;

	// enter the loop
	std::string menu_string;
	do {
		// print the separating line and the current address
		std::stringstream out;
		out << '\n' << std::string(100, '-') << '\n';
		out << "guest-address: " << print_number(address, true) << '\n';
		out << "host-address : " << print_number(context->guest.ra, true) << '\n';
		out << "block        : " << print_number(_current_index, false, 3, '0') << " ["
			<< print_number(_current->entry->x86_start, true);
		out << " - " << print_number(_current->entry->x86_end, true) << "]\n\n";

		// print the break-points
		if (_state & DebugState::print_bp)
			out << print_break_points() << '\n';

		// print the blocks
		if (_state & DebugState::print_blocks)
			out << print_blocks() << '\n';

		// print the stack
		if (_state & DebugState::print_stack)
			out << print_stack(context->guest.map.rsp, context, _stack_limit) << '\n';

		// print the flags
		if (_state & DebugState::print_flags)
			out << print_flags(context) << '\n';

		// print the registers
		if (_state & DebugState::print_reg)
			out << print_reg(context, (_state & DebugState::reg_dec) == 0, _state & DebugState::reg_riscv) << '\n';

		// print the assembly
		if (_state & DebugState::print_asm)
			out << print_assembly(address, context->guest.ra, _current, _inst_limit) << '\n';

		// check if the menu has to be printed
		if (menu_string.empty()) {
			// print the reason for the break
			if (break_point != halt_break && break_point != halt_riscv) {
				if (break_point == _run_break && (_state & DebugState::temp_break))
					out << "run-break hit!\n";
				else
					out << "break-point hit! (index: " << std::dec << break_point << ")\n";
			}
			if (break_point == halt_riscv || _step_riscv)
				out << "stepped by one riscv-instruction!\n";
			if ((_state & DebugState::init) == 0) {
				out << "initial halt! Type \"help\" for a help-menu.\n";
				_state |= DebugState::init;
			}
			if (_run_break == 0 && (_state & DebugState::await_counter))
				out << "run-counter ellapsed.\n";
			if ((_state & DebugState::await_step) && !_step_riscv)
				out << "stepped by one instruction!\n";
			if (address == _current->entry->x86_start && (_state & DebugState::await_sob))
				out << "beginning of basic-block reached!\n";
			else if (address == _current->entry->x86_end - _current->entry->offsets[_current->entry->instruction_count - 1].x86
					 && (_state & DebugState::await_eob))
				out << "ending of basic-block reached!\n";

			// clear the await-details and the break-point
			if (_state & DebugState::temp_break) {
				_state ^= DebugState::temp_break;
				_bp_count--;
			}
			_state &= ~DebugState::await;
			break_point = halt_break;
			_step_riscv = false;
		} else
			out << menu_string << '\n';

		// print the screen
		std::cout << out.str() << std::endl;

		// handle input
		menu_string = parse_input(address, context);
	} while (!menu_string.empty());

	// print the closing line
	std::cout << '\n' << std::string(100, '-') << std::endl;

	// update the halt-flag
	_halt = (_state & DebugState::await) > 0;
}

utils::guest_addr_t debugger::Debugger::enter_break(uintptr_t break_point, utils::host_addr_t address) {
	// update the counter
	if (_state & DebugState::await_counter) {
		if (_run_break > 0)
			_run_break--;
		if (_run_break == 0)
			return resolve_block(address);
	}

	// check for a stepper
	if (_state & DebugState::await_step)
		return resolve_block(address);

	// check if a break-point has been hit or if this is the init-break or if riscv has been stepped (implicitly tested)
	if (break_point != halt_break || (_state & DebugState::init) == 0)
		return resolve_block(address);

	// check if a basic block has been reached
	if ((_state & DebugState::await_eob) || (_state & DebugState::await_sob)) {
		// resolve the address, which should also update the current block
		utils::guest_addr_t guest_addr = resolve_block(address);
		if (guest_addr == 0)
			return 0;

		// check if a beginning or an end has been reached
		if ((guest_addr == _current->entry->x86_start) && (_state & DebugState::await_sob))
			return guest_addr;
		if ((guest_addr == _current->entry->x86_end - _current->entry->offsets[_current->entry->instruction_count - 1].x86) &&
			(_state & DebugState::await_eob))
			return guest_addr;
	}
	return 0;
}

utils::guest_addr_t debugger::Debugger::resolve_block(utils::host_addr_t address) {
	// check if a current basic block exists
	if (_current != nullptr) {
		if (address < _current->entry->riscv_start || address >= _current->riscv_end) {
			_current = nullptr;
			_current_index = _blocks.size() + 1;
		}
	}

	// resolve the new block, if necessary
	if (_current == nullptr) {
		// look for the basic-block
		for (size_t i = 0; i < _blocks.size(); i++) {
			if (address < _blocks[i].entry->riscv_start)
				break;
			if (address >= _blocks[i].entry->riscv_start && address < _blocks[i].riscv_end) {
				_current = &_blocks[i];
				_current_index = i;
				break;
			}
		}
		if (_current == nullptr)
			return 0;
	}

	// resolve the x86-address
	utils::host_addr_t riscv_counter = _current->entry->riscv_start;
	utils::guest_addr_t x86_counter = _current->entry->x86_start;
	for (size_t i = 0; i < _current->entry->instruction_count; i++) {
		if (riscv_counter == address)
			return x86_counter;
		else if (riscv_counter > address)
			return x86_counter - _current->entry->offsets[i - 1].x86;
		riscv_counter += _current->entry->offsets[i].riscv;
		x86_counter += _current->entry->offsets[i].x86;
	}

	// return the last instruction, as this point can only be reached, if address points within one instruction
	return x86_counter - _current->entry->offsets[_current->entry->instruction_count - 1].x86;
}

void debugger::Debugger::update_break_points(const BlockEntry& block) {
	// iterate through the x86-break-points and check if one of them has been translated
	for (size_t i = 0; i < _bp_count; i++) {
		if (_bp_array[i] != 0)
			continue;

		// check if the address lies within the new block
		if (_bp_x86_array[i] >= block.entry->x86_start && _bp_x86_array[i] < block.entry->x86_end) {
			// initialize the counters (riscv + 4, as the first instruction is the jump to the debug-handler)
			uintptr_t x86_counter = block.entry->x86_start;
			uintptr_t riscv_counter = block.entry->riscv_start + 4;

			// iterate through the instructions and look for the one of the break-point
			for (size_t j = 0; j < block.entry->instruction_count; j++) {
				if ((_bp_x86_array[i] >= x86_counter && _bp_x86_array[i] < x86_counter + block.entry->offsets[j].x86) ||
					(j + 1 == block.entry->instruction_count)) {
					_bp_array[i] = riscv_counter;
					_bp_x86_array[i] = x86_counter;
					break;
				}
				riscv_counter += block.entry->offsets[j].riscv;
				x86_counter += block.entry->offsets[j].x86;
			}
		}

		// check if a break-point already exists for this address
		if (_bp_array[i] == 0)
			continue;
		bool move = false;
		for (size_t j = 0; j < _bp_count; j++) {
			if (move) {
				_bp_x86_array[j - 1] = _bp_x86_array[j];
				_bp_array[j - 1] = _bp_array[j];
				continue;
			}
			if (i == j || _bp_x86_array[i] != _bp_x86_array[j])
				continue;
			move = true;
		}

		// check if an entry has been removed
		if (move)
			_bp_count--;
	}
}

void debugger::Debugger::translate_break_point(uint16_t index) {
	// iterate through the blocks and check if one of them suits the break-point
	utils::guest_addr_t address = _bp_x86_array[index];
	for (size_t i = 0; i < _blocks.size(); i++) {
		// check if the current block is above the address
		if (address < _blocks[i].entry->x86_start)
			break;

		// check if the address lies within the block
		if (address >= _blocks[i].entry->x86_start && address < _blocks[i].entry->x86_end) {
			// initialize the counters (riscv + 4, as the first instruction is the jump to the debug-handler)
			uintptr_t x86_counter = _blocks[i].entry->x86_start;
			uintptr_t riscv_counter = _blocks[i].entry->riscv_start + 4;

			// iterate through the instructions and look for the one of the break-point
			for (size_t j = 0; j < _blocks[i].entry->instruction_count; j++) {
				if ((address >= x86_counter && address < x86_counter + _blocks[i].entry->offsets[j].x86) ||
					(j + 1 == _blocks[i].entry->instruction_count)) {
					_bp_array[index] = riscv_counter;
					_bp_x86_array[index] = x86_counter;
					return;
				}
				x86_counter += _blocks[i].entry->offsets[j].x86;
				riscv_counter += _blocks[i].entry->offsets[j].riscv;
			}
		}
	}

	// clear the break-point, as the block has not yet been translated
	_bp_array[index] = 0;
}