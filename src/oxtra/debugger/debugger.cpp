#include "debugger.h"
#include <string>
#include <iostream>
#include <csignal>

#include "oxtra/logger/logger.h"
#include "oxtra/dispatcher/dispatcher.h"

debugger::DebuggerBatch::DebuggerBatch() {
	_adding_jump = false;
}

size_t debugger::DebuggerBatch::add(utils::riscv_instruction_t inst) {
	// add the jump to the debug-procedure (_adding_jump is needed, as jump_debugger_riscv will call add() internally)
	// ignore the first instruction, as the first instruction is generated by the debugger (x86-jump)
	// ignore the second instruction, as there is no reason for an x86-bp followed by a riscv-bp
	if (Debugger::step_riscv() && !_adding_jump && count > 1) {
		_adding_jump = true;
		codegen::jump_table::jump_debugger_riscv(*this);
		_adding_jump = false;
	}
	riscv[count] = inst;
	return count++;
}

void debugger::DebuggerBatch::print() const {
	if (Debugger::step_riscv()) {
		for (size_t i = 1; i < count; i += 2)
			logger::riscv("    [{:02}] = {}\n", i / 2, decoding::parse_riscv(riscv[i]));
	} else {
		for (size_t i = 1; i < count; i++)
			logger::riscv("    [{:02}] = {}\n", i - 1, decoding::parse_riscv(riscv[i]));
	}
}

size_t debugger::DebuggerBatch::offset(size_t start, size_t end) {
	if (Debugger::step_riscv()) {
		if (start == end)
			return 0;
		if (start & 0x01u) {
			if (end & 0x01u)
				return end - start - 1;
			else
				return end - start;
		} else if (end & 0x01u)
			return end > start ? end - start - 1 : end - start - 2;
		return end - start - 1;
	} else
		return end - start;
}

debugger::Debugger* debugger::Debugger::active_debugger = nullptr;

debugger::Debugger::Debugger(const elf::Elf& elf, dispatcher::ExecutionContext* context, bool riscv_enabled,
							 uintptr_t stack_low, uintptr_t stack_size) : _elf{elf} {
	// initialize the attributes
	_halt = true;
	_bp_count = 0;
	_state = DebugState::none;
	_run_break = 0;
	_current = nullptr;
	_current_index = 1;
	_inst_limit = 8;
	_stack_limit = 8;
	_step_riscv = false;
	_riscv_enabled = riscv_enabled;
	_stack_low = stack_low;
	_stack_high = stack_low + stack_size;
	_context = context;
	_signal_address = 0;

	// mark this as the active debugger
	active_debugger = this;
}

debugger::Debugger::~Debugger() {
	// reset the active debugger
	if (active_debugger == this)
		active_debugger = nullptr;
}

bool debugger::Debugger::step_riscv() {
	// check if a debugger exists
	if (!active_debugger)
		return false;

	return active_debugger->_riscv_enabled;
}

void debugger::Debugger::begin_block(codegen::CodeBatch& batch) {
	unused_parameter(batch);
}

void debugger::Debugger::insert(codegen::CodeBatch& batch, codegen::Instruction* inst) {
	unused_parameter(inst);

	// check if a debugger exists
	if (!active_debugger)
		return;

	// add the instruction to jump to the debugger
	codegen::jump_table::jump_debugger(batch);
}

void debugger::Debugger::end_block(codegen::CodeBatch& batch, codegen::codestore::BlockEntry* block) {
	unused_parameter(batch);

	// check if a debugger exists
	if (!active_debugger)
		return;

	// compute the end of the riscv-instructions
	utils::host_addr_t riscv_end = block->riscv_start;
	for (size_t i = 0; i < block->instruction_count; i++)
		riscv_end += block->offsets[i].riscv;

	// insert the block into the sorted list
	size_t insert_index = active_debugger->_blocks.size() + 1;
	for (size_t i = 0; i < active_debugger->_blocks.size(); i++) {
		if (active_debugger->_blocks[i].entry->x86_start > block->x86_start) {
			active_debugger->_blocks.emplace(active_debugger->_blocks.begin() + i, block, riscv_end);
			insert_index = i;
			break;
		}
	}
	if (insert_index > active_debugger->_blocks.size()) {
		active_debugger->_blocks.emplace_back(block, riscv_end);
		insert_index--;
	} else if (insert_index >= active_debugger->_current_index)
		active_debugger->_current_index++;

	// update the current block
	if (active_debugger->_current_index != active_debugger->_blocks.size())
		active_debugger->_current = &active_debugger->_blocks[active_debugger->_current_index];
	else
		active_debugger->_current_index = active_debugger->_blocks.size() + 1;

	// update the break-points
	active_debugger->update_break_points(active_debugger->_blocks[insert_index]);
}

void debugger::Debugger::signal_handler(int signum) {
	// resolve the block
	utils::guest_addr_t guest_addr = active_debugger->resolve_block(active_debugger->_signal_address);
	if (guest_addr == 0)
		std::cout << "signal raised outside of known guest-code!\n" << std::endl;
	else {
		// update the context
		for (size_t i = 0; i < 31; i++)
			active_debugger->_context->guest.reg[i] = active_debugger->_signal_registers[i];

		// print the blocks
		std::cout << active_debugger->print_blocks() << '\n';

		// print the stack
		std::cout << active_debugger->print_stack(active_debugger->_context->guest.map.rsp, active_debugger->_stack_limit)
				  << '\n';

		// print the flags
		std::cout << active_debugger->print_flags() << '\n';

		// print the registers
		std::cout << "x86 " << active_debugger->print_reg(true, false) << '\n';
		std::cout << "riscv " << active_debugger->print_reg(true, true) << '\n';

		// print the assembly
		std::cout << active_debugger->print_assembly(guest_addr, active_debugger->_signal_address,
													 active_debugger->_current, active_debugger->_inst_limit) << '\n';
	}

	// print some default information
	if (signum == SIGSEGV)
		std::cout << "Error: Segmentation-fault!" << std::endl;
	else if (signum == SIGILL)
		std::cout << "Error: Illegal-instruction!" << std::endl;
	std::cout << "  host-address : " << print_number(active_debugger->_signal_address, true) << '\n';
	if (guest_addr != 0) {
		std::cout << "  guest-address: " << print_number(guest_addr, true) << '\n';
		std::cout << "  block-index  : " << print_number(active_debugger->_current_index, false, 3, '0') << '\n';
		std::cout << "  block-guest  : [" << print_number(active_debugger->_current->entry->x86_start, true);
		std::cout << " - " << print_number(active_debugger->_current->entry->x86_end, true) << "]\n";
		std::cout << "  block-host   : [" << print_number(active_debugger->_current->entry->riscv_start, true);
		std::cout << " - " << print_number(active_debugger->_current->riscv_end, true) << "]\n";
	} else {
		std::cout << "  guest-address: unknown!\n";
		std::cout << "  block-index  : unknown!\n";
		std::cout << "  block-guest  : [unknown - unknown]\n";
		std::cout << "  block-host   : [unknown - unknown]\n";
	}
	std::cout << std::endl;

	// fault-exit
	dispatcher::Dispatcher::fault_exit("guest segmentation-faulted!");
}

void debugger::Debugger::entry(uintptr_t break_point) {
	// check if the debugger should be entered
	utils::guest_addr_t address = enter_break(break_point, _context->guest.ra);
	if (address == 0)
		return;

	// enter the loop
	std::string menu_string;
	do {
		// print the separating line and the current address
		std::stringstream out;
		out << '\n' << std::string(100, '-') << '\n';
		out << "guest-address: " << print_number(address, true) << '\n';
		out << "host-address : " << print_number(_context->guest.ra, true) << '\n';
		out << "block-index  : " << print_number(_current_index, false, 3, '0') << '\n';
		out << "block-guest  : [" << print_number(_current->entry->x86_start, true);
		out << " - " << print_number(_current->entry->x86_end, true) << "]\n";
		out << "block-host   : [" << print_number(_current->entry->riscv_start, true);
		out << " - " << print_number(_current->riscv_end, true) << "]\n\n";

		// print the break-points
		if (_state & DebugState::print_bp)
			out << print_break_points() << '\n';

		// print the blocks
		if (_state & DebugState::print_blocks)
			out << print_blocks() << '\n';

		// print the stack
		if (_state & DebugState::print_stack)
			out << print_stack(_context->guest.map.rsp, _stack_limit) << '\n';

		// print the flags
		if (_state & DebugState::print_flags)
			out << print_flags() << '\n';

		// print the registers
		if (_state & DebugState::print_reg)
			out << print_reg((_state & DebugState::reg_dec) == 0, _state & DebugState::reg_riscv) << '\n';

		// print the assembly
		if (_state & DebugState::print_asm)
			out << print_assembly(address, _context->guest.ra, _current, _inst_limit) << '\n';

		// check if the menu has to be printed
		if (menu_string.empty()) {
			// print the reason for the break
			if (break_point != halt_break && break_point != halt_riscv) {
				if (break_point == _run_break && (_state & DebugState::temp_break))
					out << "run-break hit!\n";
				else
					out << "break-point hit! (index: " << std::dec << break_point << ")\n";
			}
			if (_step_riscv) {
				if (_state & DebugState::await_counter)
					out << "riscv-counter elapsed!\n";
				else
					out << "stepped by one riscv-instruction!\n";
			}
			if ((_state & DebugState::init) == 0) {
				out << "initial halt! Type \"help\" for a help-menu.\n";
				_state |= DebugState::init;
			}
			if (_run_break == 0 && (_state & DebugState::await_counter) && !_step_riscv)
				out << "run-counter elapsed.\n";
			if ((_state & DebugState::await_step) && !_step_riscv)
				out << "stepped by one instruction!\n";
			if (address == _current->entry->x86_start && (_state & DebugState::await_sob))
				out << "beginning of basic-block reached!\n";
			else if (address == _current->entry->x86_end - _current->entry->offsets[_current->entry->instruction_count - 1].x86
					 && (_state & DebugState::await_eob))
				out << "ending of basic-block reached!\n";

			// clear the await-details and the break-point
			if (_state & DebugState::temp_break) {
				_state ^= DebugState::temp_break;
				_bp_count--;
			}
			_state &= ~DebugState::await;
			break_point = halt_break;
			_step_riscv = false;
		} else
			out << menu_string << '\n';

		// print the screen
		std::cout << out.str() << std::endl;

		// handle input
		menu_string = parse_input(address);
	} while (!menu_string.empty());

	// print the closing line
	std::cout << '\n' << std::string(100, '-') << std::endl;

	// update the halt-flag
	_halt = (_state & DebugState::await) != 0;
}

utils::guest_addr_t debugger::Debugger::enter_break(uintptr_t break_point, utils::host_addr_t address) {
	// update the counter
	if (_state & DebugState::await_counter) {
		if (_run_break > 0)
			_run_break--;
		if (_run_break == 0)
			return resolve_block(address);
	}

	// check for a stepper
	if ((_state & DebugState::await_step) || (_step_riscv && (_state & DebugState::await_counter) == 0))
		return resolve_block(address);

	// check if a break-point has been hit or if this is the init-break
	if (break_point != halt_break || (_state & DebugState::init) == 0) {
		if (!_step_riscv || (_state & DebugState::await_counter) == 0)
			return resolve_block(address);
	}

	// check if a basic block has been reached
	if ((_state & DebugState::await_eob) || (_state & DebugState::await_sob)) {
		// resolve the address, which should also update the current block
		utils::guest_addr_t guest_addr = resolve_block(address);
		if (guest_addr == 0)
			return 0;

		// check if a beginning or an end has been reached
		if ((guest_addr == _current->entry->x86_start) && (_state & DebugState::await_sob))
			return guest_addr;
		if ((guest_addr == _current->entry->x86_end - _current->entry->offsets[_current->entry->instruction_count - 1].x86) &&
			(_state & DebugState::await_eob))
			return guest_addr;
	}
	return 0;
}

utils::guest_addr_t debugger::Debugger::resolve_block(utils::host_addr_t address) {
	// check if a current basic block exists
	if (_current != nullptr) {
		if (address < _current->entry->riscv_start || address >= _current->riscv_end) {
			_current = nullptr;
			_current_index = _blocks.size() + 1;
		}
	}

	// resolve the new block, if necessary
	if (_current == nullptr) {
		// look for the basic-block
		for (size_t i = 0; i < _blocks.size(); i++) {
			if (address < _blocks[i].entry->riscv_start)
				break;
			if (address >= _blocks[i].entry->riscv_start && address < _blocks[i].riscv_end) {
				_current = &_blocks[i];
				_current_index = i;
				break;
			}
		}
		if (_current == nullptr)
			return 0;
	}

	// resolve the x86-address
	utils::host_addr_t riscv_counter = _current->entry->riscv_start;
	utils::guest_addr_t x86_counter = _current->entry->x86_start;
	for (size_t i = 0; i < _current->entry->instruction_count; i++) {
		if (riscv_counter == address)
			return x86_counter;
		else if (riscv_counter > address)
			return x86_counter - _current->entry->offsets[i - 1].x86;
		riscv_counter += _current->entry->offsets[i].riscv;
		x86_counter += _current->entry->offsets[i].x86;
	}

	// return the last instruction, as this point can only be reached, if address points within one instruction
	return x86_counter - _current->entry->offsets[_current->entry->instruction_count - 1].x86;
}

void debugger::Debugger::update_break_points(const BlockEntry& block) {
	// iterate through the x86-break-points and check if one of them has been translated
	for (size_t i = 0; i < _bp_count; i++) {
		if (_bp_array[i] != 0)
			continue;

		// check if the address lies within the new block
		if (_bp_x86_array[i] >= block.entry->x86_start && _bp_x86_array[i] < block.entry->x86_end) {
			// initialize the counters (riscv + 4, as the first instruction is the jump to the debug-handler)
			uintptr_t x86_counter = block.entry->x86_start;
			uintptr_t riscv_counter = block.entry->riscv_start + 4;

			// iterate through the instructions and look for the one of the break-point
			for (size_t j = 0; j < block.entry->instruction_count; j++) {
				if ((_bp_x86_array[i] >= x86_counter && _bp_x86_array[i] < x86_counter + block.entry->offsets[j].x86) ||
					(j + 1 == block.entry->instruction_count)) {
					_bp_array[i] = riscv_counter;
					_bp_x86_array[i] = x86_counter;
					break;
				}
				riscv_counter += block.entry->offsets[j].riscv;
				x86_counter += block.entry->offsets[j].x86;
			}
		}

		// check if a break-point already exists for this address
		if (_bp_array[i] == 0)
			continue;
		bool remove = false;
		if (i > 0) {
			if (_bp_x86_array[i] == _bp_x86_array[i - 1])
				remove = true;
		}
		if (i + 1 < _bp_count) {
			if (_bp_x86_array[i] == _bp_x86_array[i + 1])
				remove = true;
		}
		if (remove) {
			for (size_t j = i; j < _bp_count; j++) {
				_bp_x86_array[j] = _bp_x86_array[j + 1];
				_bp_array[j] = _bp_array[j + 1];
			}
			_bp_count--;
			i--;
		}
	}
}

bool debugger::Debugger::insert_break_point(uintptr_t addr, bool static_insert) {
	// sort the break-point into the array
	size_t index = _bp_count;
	if (static_insert) {
		index = 0;
		for (size_t i = _bp_count; i > 0; i--) {
			if (_bp_x86_array[i - 1] < addr) {
				index = i;
				break;
			}
			_bp_x86_array[i] = _bp_x86_array[i - 1];
			_bp_array[i] = _bp_array[i - 1];
		}
	}

	// clear the bp-address and writhe the x86-address
	_bp_array[index] = 0;
	_bp_x86_array[index] = addr;

	// iterate through the blocks and check if one of them suits the break-point
	for (size_t i = 0; i < _blocks.size(); i++) {
		// check if the current block is above the address
		if (addr < _blocks[i].entry->x86_start)
			break;

		// check if the address lies within the block
		if (addr >= _blocks[i].entry->x86_start && addr < _blocks[i].entry->x86_end) {
			// initialize the counters (riscv + 4, as the first instruction is the jump to the debug-handler)
			uintptr_t x86_counter = _blocks[i].entry->x86_start;
			uintptr_t riscv_counter = _blocks[i].entry->riscv_start + 4;

			// iterate through the instructions and look for the one of the break-point
			for (size_t j = 0; j < _blocks[i].entry->instruction_count; j++) {
				if ((addr >= x86_counter && addr < x86_counter + _blocks[i].entry->offsets[j].x86) ||
					(j + 1 == _blocks[i].entry->instruction_count)) {
					_bp_array[index] = riscv_counter;
					_bp_x86_array[index] = x86_counter;
					break;
				}
				x86_counter += _blocks[i].entry->offsets[j].x86;
				riscv_counter += _blocks[i].entry->offsets[j].riscv;
			}

			// check if the breakpoint has been inserted
			if (_bp_array[index] != 0)
				break;
		}
	}

	// check if the break-point has already existed
	if (static_insert) {
		bool remove = false;
		if (index < _bp_count) {
			if (_bp_x86_array[index] == _bp_x86_array[index + 1])
				remove = true;
		}
		if (index > 0) {
			if (_bp_x86_array[index] == _bp_x86_array[index - 1])
				remove = true;
		}
		if (remove) {
			for (size_t i = index; i < _bp_count; i++) {
				_bp_x86_array[i] = _bp_x86_array[i + 1];
				_bp_array[i] = _bp_array[i + 1];
			}
			return false;
		}
	}
	_bp_count++;
	return true;
}