#include "code_batch.h"
#include "oxtra/logger/logger.h"
#include "oxtra/dispatcher/dispatcher.h"
#include "oxtra/debugger/debugger.h"

size_t codegen::CodeBatch::size() const {
	return count;
}

void codegen::CodeBatch::operator+=(utils::riscv_instruction_t inst) {
	add(inst);
}

size_t codegen::CodeMemory::add(utils::riscv_instruction_t inst) {
	if (count >= max_size)
		dispatcher::Dispatcher::fault_exit("CodeMemory::add - buffer-overflow");

	// add the jump to the debug-procedure (_adding_jump is needed, as jump_debugger_riscv will call add() internally)
	// ignore the first instruction, as the first instruction is generated by the debugger (x86-jump)
	// ignore the second instruction, as there is no reason for an x86-bp followed by a riscv-bp

	address[count++] = inst;
	if (debugger::Debugger::step_riscv() && !_adding_jump) {
		_adding_jump = true;
		codegen::jump_table::jump_debugger_riscv(*this);
		_adding_jump = false;
	}
	return 0;
}

size_t codegen::CodeMemory::offset(size_t start, size_t end) {
	unused_parameter(start);
	unused_parameter(end);
	dispatcher::Dispatcher::fault_exit("CodeMemory::offset - unsupported");
	return 0;
}

void codegen::CodeMemory::insert(size_t index, utils::riscv_instruction_t inst) {
	address[index] = inst;
}

size_t codegen::CodeBatchImpl::add(utils::riscv_instruction_t inst) {
	if (count >= codestore::max_riscv_instructions)
		dispatcher::Dispatcher::fault_exit("CodeBatchImpl::add - buffer-overflow");
	riscv[count] = inst;
	return count++;
}

size_t codegen::CodeBatchImpl::offset(size_t start, size_t end) {
	return end - start;
}

void codegen::CodeBatchImpl::insert(size_t index, utils::riscv_instruction_t inst) {
	riscv[index] = inst;
}

void codegen::CodeBatchImpl::reset() {
	count = 0;
}

void codegen::CodeBatchImpl::end() {
}

void codegen::CodeBatchImpl::print() const {
	for (size_t i = 0; i < count; ++i)
		logger::log(logger::Level::riscv, "    [{:02}] = {}\n", i, decoding::parse_riscv(riscv[i]));
}

utils::riscv_instruction_t* codegen::CodeBatchImpl::get() {
	return riscv;
}