QEMU \cite{qemu} is the only currently existing emulator that can perform dynamic binary translation between x86-64 and RISC-V; it can provide both full system and user space emulation (although there are other DBT in the opposite direction \cite{rv8}).

\subsection{QEMU}
	QEMU allows the translation between numerous ISAs, including x86-64 and RISC-V. While this makes QEMU very versatile, it also forces the developers to make design decisions that inhibit its performance. The most obvious bottleneck is that QEMU translates incoming binaries into an internal intermediate representation, which is then translated for the target platform. This intermediate representation is very verbose since it has to be as general as possible, and its verbosity carries over into the instructions generated for the target platform.
	
	Additionally, QEMU only ever stores a fraction of the translated code. While this saves on memory, it necessitates a context switch between the emulator and the executed program every time a control flow altering instruction is encountered.

\subsection{TinyEmu}
	In contrast to QEMU, \emph{TinyEmu} focuses on two architectures: x86-64 and RISC-V. It can execute Linux programs compiled for RISC-V on x86-64. More importantly, TinyEmu also provides an x86-64 emulator that uses KVM\footnote{KVM is an ubiquitous software stack that allows virtualization (mostly for x86-64). See \url{https://www.linux-kvm.org/page/Main_Page} (visited on 15/10/2019) for more information.} interfaces to directly execute x86-64 instructions. This means that TinyEmu can only execute x86-64 programs if the underlying host is x86-64 and RISC-V is merely emulated. Oxtra was always run on x86-64 computers and could have been compared to TinyEmu but we decided against it. Comparing the execution speed would not be fair due to the use of the KVM API with which TinyEmu claims to achieve near native performance \cite{tinyemu}.

\subsection{UNCOL}
	There have been attempts to resolve this problem of different architectures, and languages once and for all. The Universal Computer Oriented Language (UNCOL) is one of these attempts to address the problem \cite{uncol}. The idea was to create an intermediate language, which every compiler could compile too. Then, an architecture specific compiler could compile the intermediate language into byte code understandable by the underlying architecture. UNCOL was soon after declared impossible, as there were too many different types of machines and architectures back then. But there are some successful intermediate languages. Java is an example of one of them. It is translated into an intermediate byte code, which is then interpreted (or even just in time compiled) by a java virtual machine running on the host system.